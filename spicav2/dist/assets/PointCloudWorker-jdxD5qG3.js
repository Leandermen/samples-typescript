import{fk as D,q as S,f as v,ef as C,fl as k}from"./index-CI45JMVu.js";import{O as x}from"./quat-DM-4khch.js";import{e as F}from"./quatf64-Bdb9ZJJK.js";import{t as A,n as w}from"./vec3f32-nZdmKIgz.js";import{a as R,b as U,d as B}from"./PointCloudUniqueValueRenderer-BqArop50.js";import{w as J,l as N,c as V,I as q}from"./I3SBinaryReader-CyEQvnnp.js";import{O as T}from"./orientedBoundingBox-DqsqX5gI.js";import"./mat3f64-q3fE-ZOt.js";import"./VertexAttribute-BlT9lbVY.js";import"./mat4f64-CSKppSlJ.js";import"./computeTranslationToOriginAndRotation-BCHICmlc.js";import"./plane-DbJBZEog.js";function _(c,t,s,n){const{rendererJSON:f,isRGBRenderer:p}=c;let r=null,l=null;if(t&&p)r=t;else if(t&&(f==null?void 0:f.type)==="pointCloudUniqueValueRenderer"){l=R.fromJSON(f);const e=l.colorUniqueValueInfos;r=new Uint8Array(3*n);const i=g(l.fieldTransformType);for(let o=0;o<n;o++){const u=(i?i(t[o]):t[o])+"";for(let a=0;a<e.length;a++)if(e[a].values.includes(u)){r[3*o]=e[a].color.r,r[3*o+1]=e[a].color.g,r[3*o+2]=e[a].color.b;break}}}else if(t&&(f==null?void 0:f.type)==="pointCloudStretchRenderer"){l=U.fromJSON(f);const e=l.stops;r=new Uint8Array(3*n);const i=g(l.fieldTransformType);for(let o=0;o<n;o++){const u=i?i(t[o]):t[o],a=e.length-1;if(u<e[0].value)r[3*o]=e[0].color.r,r[3*o+1]=e[0].color.g,r[3*o+2]=e[0].color.b;else if(u>=e[a].value)r[3*o]=e[a].color.r,r[3*o+1]=e[a].color.g,r[3*o+2]=e[a].color.b;else for(let b=1;b<e.length;b++)if(u<e[b].value){const m=(u-e[b-1].value)/(e[b].value-e[b-1].value);r[3*o]=e[b].color.r*m+e[b-1].color.r*(1-m),r[3*o+1]=e[b].color.g*m+e[b-1].color.g*(1-m),r[3*o+2]=e[b].color.b*m+e[b-1].color.b*(1-m);break}}}else if(t&&(f==null?void 0:f.type)==="pointCloudClassBreaksRenderer"){l=B.fromJSON(f);const e=l.colorClassBreakInfos;r=new Uint8Array(3*n);const i=g(l.fieldTransformType);for(let o=0;o<n;o++){const u=i?i(t[o]):t[o];for(let a=0;a<e.length;a++)if(u>=e[a].minValue&&u<=e[a].maxValue){r[3*o]=e[a].color.r,r[3*o+1]=e[a].color.g,r[3*o+2]=e[a].color.b;break}}}else r=new Uint8Array(3*n).fill(255);if(s&&(l!=null&&l.colorModulation)){const e=l.colorModulation.minValue,i=l.colorModulation.maxValue,o=.3;for(let u=0;u<n;u++){const a=s[u],b=a>=i?1:a<=e?o:o+(1-o)*(a-e)/(i-e);r[3*u]=b*r[3*u],r[3*u+1]=b*r[3*u+1],r[3*u+2]=b*r[3*u+2]}}return r}function E(c,t){if(c.encoding==null||c.encoding===""){const s=J(t,c);if(s.vertexAttributes.position==null)return;const n=N(t,s.vertexAttributes.position),f=s.header.fields,p=[f.offsetX,f.offsetY,f.offsetZ],r=[f.scaleX,f.scaleY,f.scaleZ],l=n.length/3,e=new Float64Array(3*l);for(let i=0;i<l;i++)e[3*i]=n[3*i]*r[0]+p[0],e[3*i+1]=n[3*i+1]*r[1]+p[1],e[3*i+2]=n[3*i+2]*r[2]+p[2];return e}if(c.encoding==="lepcc-xyz")return V(t).result}function h(c,t,s){return c!=null&&c.attributeInfo.useElevation?t?z(t,s):null:c!=null&&c.attributeInfo.storageInfo?q(c.attributeInfo.storageInfo,c.buffer,s):null}function z(c,t){const s=new Float64Array(t);for(let n=0;n<t;n++)s[n]=c[3*n+2];return s}function P(c,t,s,n,f){const p=c.length/3;let r=0;for(let l=0;l<p;l++){let e=!0;for(let i=0;i<n.length&&e;i++){const{filterJSON:o}=n[i],u=f[i].values[l];switch(o.type){case"pointCloudValueFilter":{const a=o.mode==="exclude";o.values.includes(u)===a&&(e=!1);break}case"pointCloudBitfieldFilter":{const a=M(o.requiredSetBits),b=M(o.requiredClearBits);(u&a)===a&&!(u&b)||(e=!1);break}case"pointCloudReturnFilter":{const a=15&u,b=u>>>4&15,m=b>1,$=a===1,I=a===b;let y=!1;for(const d of o.includedReturns)if(d==="last"&&I||d==="firstOfMany"&&$&&m||d==="lastOfMany"&&I&&m||d==="single"&&!m){y=!0;break}y||(e=!1);break}}}e&&(s[r]=l,c[3*r]=c[3*l],c[3*r+1]=c[3*l+1],c[3*r+2]=c[3*l+2],t[3*r]=t[3*l],t[3*r+1]=t[3*l+1],t[3*r+2]=t[3*l+2],r++)}return r}function g(c){switch(c){default:case null:case"none":return t=>t;case"low-four-bit":return t=>15&t;case"high-four-bit":return t=>(240&t)>>4;case"absolute-value":return t=>Math.abs(t);case"modulo-ten":return t=>t%10}}function M(c){let t=0;for(const s of c||[])t|=1<<s;return t}class X{transform(t){const s=this._transform(t),n=[s.points.buffer,s.rgb.buffer];s.pointIdFilterMap!=null&&n.push(s.pointIdFilterMap.buffer);for(const f of s.attributes)"buffer"in f.values&&D(f.values.buffer)&&f.values.buffer!==s.rgb.buffer&&n.push(f.values.buffer);return Promise.resolve({result:s,transferList:n})}_transform(t){const s=E(t.schema,t.geometryBuffer);let n=s.length/3,f=null;const p=new Array,r=h(t.primaryAttributeData,s,n);t.primaryAttributeData!=null&&r&&p.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:r});const l=h(t.modulationAttributeData,s,n);t.modulationAttributeData!=null&&l&&p.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:l});let e=_(t.rendererInfo,r,l,n);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const o=t.filterAttributesData.filter(S).map(u=>{const a=h(u,s,n),b={attributeInfo:u.attributeInfo,values:a};return p.push(b),b});f=new Uint32Array(n),n=P(s,e,f,t.filterInfo,o)}for(const o of t.userAttributesData){const u=h(o,s,n);p.push({attributeInfo:o.attributeInfo,values:u})}3*n<e.length&&(e=new Uint8Array(e.buffer.slice(0,3*n))),this._applyElevationOffsetInPlace(s,n,t.elevationOffset);const i=this._transformCoordinates(s,n,T.fromData(t.obbData),v.fromJSON(t.inSR),v.fromJSON(t.outSR));return{obbData:t.obbData,points:i,rgb:e,attributes:p,pointIdFilterMap:f}}_transformCoordinates(t,s,n,f,p){if(!C(t,f,0,t,p,0,s))throw new Error("Can't reproject");const r=A(n.center),l=w(),e=w(),i=A(n.halfSize);x(O,n.quaternion);const o=new Float32Array(3*s);for(let u=0;u<s;u++){let a=3*u;l[0]=t[a]-r[0],l[1]=t[a+1]-r[1],l[2]=t[a+2]-r[2],k(e,l,O),i[0]=Math.max(i[0],Math.abs(e[0])),i[1]=Math.max(i[1],Math.abs(e[1])),i[2]=Math.max(i[2],Math.abs(e[2])),o[a++]=l[0],o[a++]=l[1],o[a]=l[2]}return n.halfSize=i,o}_applyElevationOffsetInPlace(t,s,n){if(n!==0)for(let f=0;f<s;f++)t[3*f+2]+=n}}const O=F();function rt(){return new X}export{rt as default};
